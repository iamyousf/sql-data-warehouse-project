/*
This advanced data analytics script is designed to transform raw transactional data 
from the data warehouse into meaningful business insights for reporting and decision-making. 
It analyzes sales performance over time (yearly and monthly), tracks cumulative revenue 
and moving averages, evaluates product performance against historical averages and 
previous periods, measures category contribution to overall sales, and segments both 
customers and products based on behavioral and financial metrics.

The script also builds structured reporting views (report_customer and report_product) 
that aggregate key KPIs such as total sales, order frequency, recency, lifespan, 
average order value, monthly revenue contribution, and performance classification. 
These views serve as a clean analytical layer for dashboards, BI tools, and strategic 
analysis, enabling management to monitor growth trends, customer value, product 
performance, and overall business health.
*/

USE Datawarehouse;
SELECT * FROM gold.dim_customers
SELECT * FROM gold.dim_products
Select * FROM gold.fact_sales

--ADVANCE DATA ANALYTICS

--CHANGE OVER TIME
--ANALIZE ODER DATE BY SALES IN THE TERM OF YAER AND MOUNTHS
--BY YEAR
SELECT
YEAR(order_date) AS order_year,
SUM(sales_amount) AS total_order,
COUNT(DISTINCT customer_id) AS total_customers,
SUM(quantity) AS total_quantity 
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date)
ORDER BY YEAR(order_date)
--BY MONTHS
SELECT
MONTH(order_date) AS order_month,
SUM(sales_amount) AS total_order,
COUNT(DISTINCT customer_id) AS total_customers,
SUM(quantity) AS total_quantity 
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY MONTH(order_date)
ORDER BY MONTH(order_date)
--DO IT TOGETHER
SELECT
YEAR(order_date) AS order_year,
MONTH(order_date) AS order_month,
SUM(sales_amount) AS total_order,
COUNT(DISTINCT customer_id) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY YEAR(order_date),MONTH(order_date)
ORDER BY YEAR(order_date),MONTH(order_date)
--BY USING DATETRUNC
--MONTH
SELECT
DATETRUNC(MONTH, order_date) AS order_month,
SUM(sales_amount) AS total_order,
COUNT(DISTINCT customer_id) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY DATETRUNC(MONTH, order_date)
ORDER BY DATETRUNC(MONTH, order_date)
--YEAR
SELECT
DATETRUNC(YEAR, order_date) AS order_year,
SUM(sales_amount) AS total_order,
COUNT(DISTINCT customer_id) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY DATETRUNC(YEAR, order_date)
ORDER BY DATETRUNC(YEAR, order_date)
--BY USING FORMAT
SELECT
FORMAT(order_date, 'yyyy-MMM') AS order_year,
SUM(sales_amount) AS total_order,
COUNT(DISTINCT customer_id) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY FORMAT(order_date, 'yyyy-MMM') 
ORDER BY FORMAT(order_date, 'yyyy-MMM')

--CUMLATIVE ANALYSICS

--CALCULATE THE TOTAL SALES PER MOUTH
--AND THE AVG TOTAL PRIVE OVER TIME
SELECT 
order_date,
total_sales,
SUM(total_sales) OVER (ORDER BY order_date) AS running_total_sales,
AVG(avg_price) OVER (ORDER BY order_date) AS moving_avg_price
FROM (
    SELECT
    DATETRUNC(MONTH, order_date) AS order_date,
    SUM(sales_amount) AS total_sales,
    AVG(price) as avg_price
    FROM gold.fact_sales
    WHERE order_date IS NOT NULL
    GROUP BY DATETRUNC(MONTH, order_date)
) t
ORDER BY order_date;


--PERFORMANCE ANALYSIS

--ANALZE THE YEARLY PEFROMANCE OF PRODUCTS BY COMPARING EACH PRODUCT SALES TO 
--BOTH ITS AVERAGE AND PREVIOUS YEAR SALES
WITH yearly_product_sales AS(
SELECT
YEAR(f.order_date) AS order_year,
p.product_name,
SUM(f.sales_amount) AS current_sales
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
ON f.product_key=p.product_key
WHERE f.order_date IS NOT NULL
GROUP BY YEAR(f.order_date),
p.product_name
)
SELECT 
order_year,
product_name,
current_sales,
AVG(current_sales) OVER (PARTITION BY product_name) AS yearly_sales ,
current_sales-AVG(current_sales) OVER (PARTITION BY product_name) AS diff_avg,
CASE
    WHEN current_sales-AVG(current_sales) OVER (PARTITION BY product_name)>0 THEN 'Above Avg'
    WHEN current_sales-AVG(current_sales) OVER (PARTITION BY product_name)<0 THEN 'Below Avg'
    ELSE 'Avg'
END avg_change,
LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year)  AS pre_year,
current_sales-LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) AS diff_year,
CASE
    WHEN current_sales-LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) >0 THEN 'Increase'
    WHEN current_sales-LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_year) <0 THEN 'Decrease'
    ELSE 'NO CHANGE'
END year_change
FROM yearly_product_sales
ORDER BY product_name, order_year

--NOW DO IT FOR MONTHLY 
WITH mouthly_sales_change AS(
SELECT 
FORMAT(f.order_date, 'MM MMM') AS order_month,
p.product_name,
SUM(f.sales_amount) AS current_sales
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
ON f.product_key = p.product_key
WHERE f.order_date IS NOT NULL
GROUP BY FORMAT(f.order_date, 'MM MMM'),
p.product_name
)
SELECT 
order_month,
product_name,
current_sales,
AVG(current_sales) OVER(PARTITION BY product_name) AS monthly_sales,
current_sales-AVG(current_sales) OVER(PARTITION BY product_name) AS diff_in_monthly,
CASE 
    WHEN current_sales-AVG(current_sales) OVER(PARTITION BY product_name)>0 THEN 'Above Avg'
    WHEN current_sales-AVG(current_sales) OVER(PARTITION BY product_name)<0 THEN 'Below Avg'
    ELSE 'Avg'
END avg_change,
LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_month) AS pre_month,
current_sales-LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_month) AS diff_monthly,
CASE
    WHEN current_sales-LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_month)>0 THEN 'Increase'
    WHEN current_sales-LAG(current_sales) OVER(PARTITION BY product_name ORDER BY order_month)<0 THEN 'Decraese'
    ELSE 'No Chnage'
END monthly_change
FROM mouthly_sales_change
ORDER BY product_name,order_month

--PART-TO-WHOLE

--WHICH CATEGORY CONTRIBUTES THE MOST TO OVERALLSALES
WITH category_sales AS(
SELECT 
p.category,
SUM(f.sales_amount) AS total_sales
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
ON f.product_key=p.product_key
GROUP BY p.category
)
SELECT
category,
total_sales,
SUM(total_sales) OVER() AS overall_sales,
CONCAT(ROUND((CAST(total_sales AS FLOAT) / SUM(total_sales) OVER()) * 100 ,2),'%') AS perct_of_total
FROM category_sales
ORDER BY total_sales DESC

--NOW FOR OTHER 
WITH category_order AS (
SELECT
p.category,
COUNT(f.order_number) AS total_order
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
ON f.product_key = p.product_key
GROUP BY p.category
)
SELECT 
category,
total_order,
SUM(total_order) OVER() AS overall_order,
CONCAT(ROUND((CAST(total_order AS FLOAT) / SUM(total_order) OVER() * 100), 2), '%') AS percentage_of_order
FROM category_order
ORDER BY total_order DESC

--DATA SEGMENTATIION

--SEGEMENT PRODUCT INTO COST RANGES &
--COUNT HOW MANY PRODUCT FULL INRO EACH SEGMENTS
WITH products_segement AS (
SELECT
product_key,
product_name,
cost,
CASE 
    WHEN cost <100 THEN 'Below 100'
    WHEN cost BETWEEN 100 AND 500 THEN '100-500'
    WHEN cost BETWEEN 500 AND 1000 THEN '500-1000'
    ELSE ' Above 1000'
END cost_range
FROM gold.dim_products
)
SELECT 
cost_range,
COUNT(product_key) as total_products
FROM products_segement
GROUP BY cost_range
ORDER BY total_products DESC

--GROUP CUSTOMER INTO 3 STAGES BASED ON THIER SPENDING BEHAVIOUR
--VIP- ATLEAST 12 MONTH AND SPENDING >5000
--REGULAR-- ATLEST 12 MONTH AND SPENDING <5000
--NEW -- LIFESPAN IS LEAT THAN 12 

WITH customers_groups AS(
SELECT 
c.customer_key,
SUM(f.sales_amount) AS total_spends,
MIN(f.order_date) AS first_order,
MAX(f.order_date) AS last_order,
DATEDIFF(MONTH, MIN(f.order_date), MAX(f.order_date)) AS lifespan
FROM gold.fact_sales f 
LEFT JOIN gold.dim_customers c
ON f.customer_id = c.customer_id
GROUP BY c.customer_key
)
SELECT 
customer_seq,
COUNT(customer_key) AS total_customer
FROM(
SELECT
customer_key,
total_spends,
lifespan,
CASE
    WHEN lifespan >= 12 AND total_spends > 5000 THEN 'VIP'
    WHEN lifespan >= 12 AND total_spends <= 5000 THEN 'Regular'
    ELSE 'New'
END AS customer_seq
FROM customers_groups
) t
GROUP BY customer_seq
ORDER BY total_customer DESC

--REPORTING (report for customers)
WITH based_query AS (
SELECT 
f.order_number,
f.order_date,
f.product_key,
f.sales_amount,
f.quantity,
c.customer_key,
c.customer_number,
CONCAT(c.firstname,' ' ,c.lastname) AS customer_name,
c.gender,
c.birthdate,
DATEDIFF(YEAR,c.birthdate,GETDATE()) AS age
FROM gold.fact_sales f
LEFT JOIN gold.dim_customers c
ON c.customer_id=f.customer_id
WHERE order_date IS NOT NULL
), customer_aggregation AS(
SELECT
customer_key,
customer_number,
customer_name,
age,
COUNT( DISTINCT order_number) AS total_order,
SUM(sales_amount) AS total_sales,
SUM(quantity) AS total_quantity,
COUNT( DISTINCT product_key) AS total_products,
MAX(order_date) AS last_order,
DATEDIFF(MONTH,MAX(order_date),GETDATE()) AS lifespan
FROM based_query
GROUP BY customer_key,
customer_number,
customer_name,
age
)
SELECT
customer_key,
customer_number,
customer_name,
age,
CASE
    WHEN age<20 THEN 'Teen'
    WHEN age BETWEEN 20 AND 29 THEN 'Young Adult'
    WHEN age BETWEEN 29 AND 39 THEN 'Young'
    WHEN age BETWEEN 39 AND 49 THEN 'Adult' 
    WHEN age BETWEEN 49 AND 59 THEN 'Mature'
    WHEN age BETWEEN 59 AND 69 THEN 'Senior'
    ELSE 'Elderly'
END AS age_group,
CASE 
    WHEN lifespan >= 12 AND total_sales > 5000 THEN 'VIP'
    WHEN lifespan >= 12 AND total_sales <= 5000 THEN 'Regular'
    ELSE 'New'
END AS customer_segments,
last_order,
DATEDIFF(MONTH,last_order,GETDATE()) AS recency,
total_order,
total_sales,
total_quantity,
total_products,
lifespan,
CASE
    WHEN total_sales =0 THEN 0
    ELSE total_sales/total_order
END AS avg_order_value,
CASE
    WHEN lifespan =0 THEN total_sales
    ELSE total_sales/lifespan
END AS avg_monthly_spend
FROM   customer_aggregation

--NOW CREATE A VIEW FOR REPORT
CREATE VIEW gold.report_customer AS

WITH based_query AS (
    SELECT 
        f.order_number,
        f.order_date,
        f.product_key,
        f.sales_amount,
        f.quantity,
        c.customer_key,
        c.customer_number,
        CONCAT(c.firstname,' ',c.lastname) AS customer_name,
        c.gender,
        c.birthdate,
        DATEDIFF(YEAR,c.birthdate,GETDATE()) AS age
    FROM gold.fact_sales f
    LEFT JOIN gold.dim_customers c
        ON c.customer_id = f.customer_id
    WHERE f.order_date IS NOT NULL
),

customer_aggregation AS(
    SELECT
        customer_key,
        customer_number,
        customer_name,
        age,
        COUNT(DISTINCT order_number) AS total_order,
        SUM(sales_amount) AS total_sales,
        SUM(quantity) AS total_quantity,
        COUNT(DISTINCT product_key) AS total_products,
        MAX(order_date) AS last_order,
        DATEDIFF(MONTH, MAX(order_date), GETDATE()) AS lifespan
    FROM based_query
    GROUP BY 
        customer_key,
        customer_number,
        customer_name,
        age
)

SELECT
    customer_key,
    customer_number,
    customer_name,
    age,
    CASE
        WHEN age < 20 THEN 'Teen'
        WHEN age BETWEEN 20 AND 28 THEN 'Young Adult'
        WHEN age BETWEEN 29 AND 38 THEN 'Young'
        WHEN age BETWEEN 39 AND 48 THEN 'Adult'
        WHEN age BETWEEN 49 AND 58 THEN 'Mature'
        WHEN age BETWEEN 59 AND 68 THEN 'Senior'
        ELSE 'Elderly'
    END AS age_group,
    CASE 
        WHEN lifespan >= 12 AND total_sales > 5000 THEN 'VIP'
        WHEN lifespan >= 12 AND total_sales <= 5000 THEN 'Regular'
        ELSE 'New'
    END AS customer_segments,
    last_order,
    DATEDIFF(MONTH, last_order, GETDATE()) AS recency,
    total_order,
    total_sales,
    total_quantity,
    total_products,
    lifespan,
    CASE
        WHEN total_order = 0 THEN 0
        ELSE CAST(total_sales AS FLOAT) / total_order
    END AS avg_order_value,
    CASE
        WHEN lifespan = 0 THEN total_sales
        ELSE CAST(total_sales AS FLOAT) / lifespan
    END AS avg_monthly_spend
FROM customer_aggregation

--REPORTING (report for products)
CREATE VIEW gold.report_product AS
WITH base_query1 AS (
SELECT 
f.order_number,
f.order_date,
f.product_key,
f.customer_id,
f.sales_amount,
f.quantity,
p.product_name,
p.category,
p.subcategory,
p.cost
FROM gold.fact_sales f
LEFT JOIN gold.dim_products p
ON p.product_key = f.product_key
), 
  product_aggregation AS(
SELECT
product_key,
product_name,
category,
subcategory,
cost,
DATEDIFF(MONTH, MIN(order_date), MAX(order_date)) AS lifespan,
DATEDIFF(MONTH, MAX(order_date), GETDATE()) AS last_order_month,
COUNT(DISTINCT order_number) AS total_order,
COUNT(DISTINCT customer_id) AS total_customer,
SUM(sales_amount) AS total_sales,
SUM(quantity) AS total_quantity,
ROUND(AVG(CAST(sales_amount AS FLOAT) / NULLIF(quantity,0)),1) AS avg_selling_price
FROM base_query1
GROUP BY
product_key,
product_name,
category,
subcategory,
cost
)
SELECT
product_key,
product_name,
category,
subcategory,
cost,
DATEDIFF(MONTH,last_order_month,GETDATE()) AS recency,
CASE
    WHEN total_sales > 50000 THEN 'High Performance'
    WHEN total_sales >=10000 THEN 'Mid Performance'
    ELSE 'Low Performance'
END AS product_segment,
lifespan,
last_order_month,
total_order,
total_customer,
total_sales,
total_quantity,
avg_selling_price,
CASE
    WHEN total_order=0 THEN 0
    ELSE total_sales/total_order
END AS avg_order_revenue,
CASE
    WHEN lifespan =0 THEN total_sales
    ELSE total_sales/ lifespan
END AS avg_monthly_rev
FROM product_aggregation 

--BOTH CUSTOMER AND PRODUCT REPOET VIEW
SELECT * FROM gold.report_customer
SELECT * FROM gold.report_product
